

\section{Notations and Background}
\label{sec:Notation}

In this paper, we focus on the programs modeled by (Boolean) formulas.
In the formulas being discussed, the symbols $x$ and $y$ denote variables, and literal $l$ refers to either the variable $x$ or its negation $\neg x$, where $var(l)$ represents the variable underlying the literal $l$.
$PV = \left\{x_0,x_1,...,x_n,... \right\} \cup \left\{y_0,y_1,...,y_n,... \right\}$ denotes a set of Boolean variables.
A formula $\varphi$ is constructed from the constants $\mathit{true}$, $\mathit{false}$ and variables using negation operator $\neg$, conjunction operator $\wedge$, disjunction operator $\vee$ and equality operator $\leftrightarrow$, where $\mathit{Vars}(\varphi)$ denotes the set of variables appearing in $\varphi$.
A clause $C$ (resp. term $T$) is a set of literals representing their disjunction (resp. conjunction).
A formula in conjunctive normal form (CNF) is a set of clauses representing their conjunction.
Given a formula $\varphi$, a variable $x$, and a constant $b$, the substitution $\varphi[x \mapsto b]$ refers to the transformed formula obtained by substituting the occurrence of $x$ with $b$ throughout $\varphi$.

An assignment $\sigma$ over variable set $V$ is a mapping from $V$ to $\{ \mathit{true}, \mathit{false} \}$, and can be seen as a term $T(\sigma) = \bigwedge_{x \mapsto \mathit{true} \in \sigma} x \land \bigwedge_{x \mapsto \mathit{false} \in \sigma} \lnot x$.
The set of all assignments over $V$ is denoted by $2^V$.
Given a subset $V' \subseteq V$, $\sigma_{\downarrow V'} = \{x \mapsto b \in \sigma \mid x \in V'\}$.
Given a formula $\varphi$, an assignment over $\mathit{Vars}(\varphi)$ satisfies $\varphi$ ($\sigma \models \varphi$) if the substitution $\varphi[\sigma]$ is equivalent to $\mathit{true}$.
A satisfying assignment is also called solution or model.
We use $\mathit{Sol}(\varphi)$ to the set of solutions of $\varphi$, and model counting is the problem of computing $|\mathit{Sol}(\varphi)|$.   
Given two formulas $\varphi$ and $\psi$ over $V$, $\varphi \models \psi$ iff $\mathit{Sol}(\varphi) \subseteq \mathit{Sol}(\psi)$.
An implied literal $l$ of a formula $\varphi$ satisfies $\varphi \models l$. 
Given a formula, we can use its implied literals to simplify it.

\begin{example}\label{testenv-example}
Given a CNF formula $\varphi = x_1  \wedge (x_1 \vee x_2 \vee x_5) \wedge (\neg x_1 \vee x_3) \wedge (\neg x_2 \vee \neg x_3) \wedge (x_2 \vee x_4 \vee \neg x_5)$, it has three implied literals $\{x_1, \neg x_2, x_3\}$.
Then, $\varphi$ can be simplified as $x_1 \land \neg x_2 \land x_3 \land (x_4 \vee \neg x_5)$.
\end{example}


% $\textbf{Knowledge Compliation}$

\subsection{Circuit formula and its Shannon entropy}
%This paper's research method focuses on computing the entropy of programs modeled by Boolean formulas using model counting.
Given a formula $\varphi(X, Y)$ to represent the relationship between input variables $X$ and output variables $Y$, if $\sigma_{1 \downarrow X} = \sigma_{2 \downarrow X} \Longrightarrow \sigma_1 = \sigma_2$ for each $\sigma_1,\sigma_2 \in \mathit{Sol}(\varphi)$, then we say $\varphi$ is a circuit formula.
It is standard in the security community to employ circuit formulas to model programs in QIF~\cite{golia2022scalable}.
%such that for any given assignment of values to $X$, there exists at most one assignment of values to $Y$ that satisfies the formula $\varphi$; $X$ can be considered as the set of inputs, while $Y$ can be considered as the set of outputs.

\begin{example}\label{circuit-example}
	The following CNF formula is a circuit formula with input variables $X = \{x_1,x_2,x_3,x_4 \}$ and output variables $Y = \{ y_1,y_2,y_3 \}$:
	
	\begin{equation*}
		\begin{split}
			\varphi(X, Y) = & (x_1 \vee x_2) \wedge (\neg x_1 \vee x_2) \wedge (\neg x_1 \vee y_1) \\ 
			\wedge (x_1 \vee \neg y_1) \wedge  (x_3 \vee x_4 \vee y_1) \wedge \\ 
			&  (\neg x_3 \vee \neg x_4 \vee y_3) \wedge (x_3 \vee \neg y_3) \wedge (x_4 \vee \neg y_3) \wedge (y_1 \vee \neg y_2) \wedge (\neg x_1 \vee \neg y_2) .
		\end{split} 
	\end{equation*}
\end{example}


\begin{proposition}\label{projected-proposition}
Given a circuit formula $\varphi$, the projected model counting of formula $\varphi$ under $X$ is equal to the number of models of formula $\varphi$, i.e. $ \left| \mathit{Sol}(\varphi)_{\downarrow X} \right| = \left| \mathit{Sol}(\varphi)  \right|$	
\end{proposition}

\begin{proof}
		Let $\sigma_{\downarrow X}$ represent the assignment of variables restricted to $X$.
		Since $\varphi$ is a circuit formula, each input uniquely corresponds to an output.
		If for each $\sigma_1, \sigma_2 \in \mathit{Sol}(\varphi)$, we have $\sigma_{1_{\downarrow X}} = \sigma_{2_{\downarrow X}} \Longrightarrow \sigma_{1_{\downarrow X}} = \sigma_{2_{\downarrow X}}$. 
		At the same time, we also know that $X \subseteq Vars(\varphi)$.
		So, we have $ \left| \mathit{Sol}(\varphi)_{\downarrow X} \right| = \left| \mathit{Sol}(\varphi)  \right|$
\end{proof}


    In the computation of Shannon entropy, we focus on the probability of each output.
	Let $p$ be a probability distribution defined over the set $\{0,1\}^Y$.
	For each assignment $\sigma$ to $Y$, i.e., $\sigma:Y \mapsto \{0,1\}$, the probability is defined as $p_{\sigma} = \frac{\left| \mathit{Sol}(\varphi(Y \mapsto \sigma)) \right|}{ \left| \mathit{Sol}(\varphi)_{\downarrow X} \right| }$, where $\mathit{Sol}(\varphi(Y \mapsto \sigma))$ denotes the set of solutions of $\varphi(Y \mapsto \sigma)$ and $\mathit{Sol}(\varphi)_{\downarrow X}$ denotes the set of solutions of $\varphi$ projected to $X$.
	Then, the entropy of $\varphi$ is $H(\varphi) = \sum_{\sigma \in 2^Y} -p_{\sigma} \log {p_{\sigma}}$.
To facilitate the description of the algorithm, we define the self-information of a sub-formula $\varphi \land T(\sigma)$ with $\mathit{Vars}(T(\sigma)) \subseteq Y$ as
$\mathit{infor}(\sigma, \varphi) = \sum_{\sigma' \in 2^Y \land \sigma' \models T(\sigma)} -p_{\sigma'} \log {p_{\sigma'}}$.
It is obvious that the self-information of $\varphi$ is the entropy.
Moreover, $\varphi[\sigma]$ is still a circuit formula with the output variables $Y \setminus \mathit{Vars}(T(\sigma))$.



\subsection{Algebraic Decision Diagrams}
The Algebraic Decision Diagram with Propositional Language Containing Implied Literals (ADD-L) proposed in this paper is an extended form based on Algebraic Decision Diagram (ADD~\cite{bahar1997algebric}).
ADD is an extended version of BDD that incorporates multiple terminal nodes, each assigned a real-valued. 
ADD is a compact representation of a real-valued function as a directed acyclic graph. 
For functions that have a logical structure, the ADD notation can be exponentially smaller than the explicit notation. 

The original design motivation for ADD was to solve matrix multiplication, shortest path algorithms, and direct methods for numerical linear algebra~\cite{bahar1997algebric}.
In subsequent research, ADD has also been used for stochastic model checking~\cite{kwiatkowska2007stochastic}, stochastic programming~\cite{hoey2013spudd}, and weighted model counting~\cite{dudek2020addmc}.

We consider an ADD consisting of a quadruple $(X,S,\pi,G)$, where $X$ is the set of variables of a Boolean formula, $S$ is an arbitrary set (called the carrier set), and $\pi$ is the order of occurrence of the variables, $G$ is a rooted directed acyclic graph~\cite{dudek2020addmc}.
An ADD is a rooted directed acyclic graph $G$, where the labels of the non-terminal nodes are elements in the set $X$ and have two outgoing edges labeled $0$ and $1$ (referred to as $lo$ edge and $hi$ edge in this paper), and all the terminal nodes are labeled with an element in the set $S$.
The order of the appearance of the labels of non-terminal nodes in all paths from the root to the terminal nodes in $G$ must be consistent with the order of the elements in $\pi$.



